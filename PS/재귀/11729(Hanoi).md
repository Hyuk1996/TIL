# 백준 11729

[문제 출처](https://www.acmicpc.net/problem/11729)

<br/>

- **문제 해석**

첫 번째 장대에 쌓여 있는 n(1 <= n <= 20) 개의 원판을 세 번째 장대로 옮긴다. 

이때 두 가지 규칙이 있다.

1. 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
2. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.

이를 수행하는 데 필요한 최소 이동 횟수와, 이동 순서를 구하라.

<br/>

- **계획**

첫 번째 장대에 있는 n 개의 원판을 두 번째 장대를 통해 세 번째 장대에 옮기는 과정을 쪼개보자.

1. n-1개의 원판을 세 번째 장대에를 통해 두 번째 장대에 옮긴다.
2. 첫 번째 장대 가장 마지막에 있던 원판을 세 번째 장대에 옮긴다.
3. 두 번째 장대에 있는 n-1개의 원판을 첫 번째 장대를 통해 세 번째 장대에 옮긴다.

위의 과정을 통하면 첫 번째 장대에 있는 n 개의 원판을 세 번째 장대에 옮길 수 있다.

<br/>

위의 과정을 조금 더 자세히 보면 1, 3번 과정은 결국 우리가 하려는 '첫 번째 장대에서 n 개의 원판을 세 번째 장대로 옮기는 작업'과 비슷한 작업이다. 따라서 해당 문제는 재귀 호출을 이용할 수 있다. 

<br/>

재귀 호출을 이용해 제한 시간 안에 문제를 해결할 수 있을지 시간 복잡도를 계산해보자. 

f(n)을 n 개의 원판을 옮기는 횟수라고 하자.

그러면 f(n) = 2(fn-1) + 1 과 같다. 이를 정리하면 (f(n)+1) = 2(f(n-1)+1) 따라서 f(n) = (2^n) - 1임을 알 수 있다. 

이를 이용하면 입력이 n 일 때 재귀 함수가 (2^n)-1번 수행되므로 시간 복잡도가 O(2^n) 임을 알 수 있다. 그리고 n의 최대 크기가 20이므로 제한 시간 1초 안에 수행 가능함을 알 수 있다. 

<br/>

- **내 소스 코드**

```c++
#include <iostream>
using namespace std;

void RecursiveHanoi(int n, int start, int by, int to){
    if( n == 1){
        cout << start << " " << to << "\n";
    }
    else{
        RecursiveHanoi(n-1, start, to, by);
        cout << start << " " << to << "\n";
        RecursiveHanoi(n-1, by, start, to);
    }
}

int main()
{
    int n;
    cin >> n;
    cout << (1 << n) -1 << "\n";
    RecursiveHanoi(n, 1, 2, 3);
    return 0;
}
```

<br/>

- **느낀점**

어느 문제를 해결하는 방법이 해당 문제를 쪼개서 더 작은 문제로 바꿀 수 있으면 재귀 호출로 접근해야겠다. 