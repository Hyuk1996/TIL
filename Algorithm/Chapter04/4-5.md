# 4-5 시간 복잡도

시간 복잡도란 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다. 

여기서 주의해야 할 점이 하나 있다. 시간 복잡도가 낮다고 해서 언제나 빠르게 동작하는 것은 아니다. 왜냐하면 입력의 크기에 대한 함수로 표현한 것이기 때문에 입력의 크기가 매우 작으면 시간 복잡도는 큰 의미를 갖지 못할 수도 있다. 



## - 입력의 종류에 따른 수행 시간의 변화

입력의 크기가 수행 시간을 결정하는 유일한 척도는 아니다. 입력의 구성에 따라 수행 시간이 변화할 수 있다. 

다음은 이와 관련된 예이다. 

------

Q. 배열에서 주어진 숫자를 찾고 그 위치를 반환하는 함수.

```c++
int firstIndex(const vector<int>& array, int element){
  for(int i = 0; i < array.size(); ++i)
    if(array[i] == element)
      return i;
  return -1;
}
```

위의 코드는 입력받는 배열의 구성에 따라 수행 시간이 달라진다. 이와 같은 경우는 입력의 종류에 따라 수행 시 시간이 달라지는 경우를 고려해 최선, 최악의 경우, 그리고 평균적인 경우에 대한 수행 시간을 각각 따로 계산한다.

- 최선의 수행 시간 : 1
- 최악의 수행 시간 : N
- 평균적인 경우의 수행 시간 : N/2

------

입력의 종류에 따라 수행 시간이 달라지는 경우는 최선, 최악, 그리고 평균적인 경우에 대한 수행 시간을 각각 따로 계산한다. 하지만 최악의 수행 시간 혹은 평균적인 경우의 수행 시간을 주로 사용한다. 



## - 점근적 시간 표기: O표기

시간 복잡도로 알고리즘의 수행 시간을 표기하면 계산하기 너무 힘들다는(모든 연산수를 다 세야 됨) 단점이 있다. 

따라서 이러한 단점을 해결하기 위해 Big-O Notation을 이용해 알고리즘의 수행 시간을 표현한다. 간단하게 Big-O Notation은 주어진 시간 복잡도에서 가장 빨리 증가하는 항만 남기고 다 버리는 표기법이다. 

다음은 Big-O Notation의 예이다. 

------

|                  | 알고리즘 수행 시간 | O 표기     |
| ---------------- | ------------------ | ---------- |
| 이동 평균 구하기 | N                  | O(N)       |
| 이진 탐색        | logN               | O(logN)    |
| 집합 덮개        | NM(2^M)            | O(NM(2^M)) |

------

알고리즘의 입력의 크기가 두 개 이상의 변수로 표현될 때는 가장 빨리 증가하는 항들만을 남기고 나머지를 버린다.

다음은 예이다.

------

- 2^M = O(2^M)
- 1/64(N^2)M + 64NM = O((N^2)M)
- (N^2)M + NlogM + N(M^2) = O((N^2)M + N(M^2))
- 42 = O(1) (상수 시간)

------



## - O 표기법의 의미 

O 표기법의 의미는 대략적으로 함수의 상환을 나타낸다는 의미가 있다.

다음은 f(N) = O(g(N))의 의미이다.

------

아주 큰 N' 와 C (N', C > 0)를 적절히 선택하면 N'<=N인 모든 N에 대해 |f(N)| <= C*|g(N)|이 참이 되도록 할 수 있다. 

------

*O 표기법이 수행 시간의 상한을 나타낸다는 사실을 통해 알고리즘의 최악의 수행 시간을 알아냈다고 착각할 수 있다. 하지만 최악의 수행 시간과는 관련이 없다. 



## 시간 복잡도 분석 연습

- 선택 정렬 알고리즘(selection sort)

선택 정렬 알고리즘은 모든 i에 대해 A[i..N-1]에서 가장 작은 원소를 찾은 뒤, 이것을 A[i]에 넣는 것을 반복합니다. 

```c++
void selectionSort(vector<int>& A){
  for(int i = 0; i < A.size(); ++i){
    int minIndex = i;
    for(int j = i+1; j < A.size(); ++j)
      if(A[minIndex] > A[j])
        minIndex = j;
    swap(A[i], A[minIndex]);
  }
}
```

선택 정렬 알고리즘의 시간 복잡도를 계산해보자.

(N-1) + (N-2) + ... + (1) = 1/2(N^2) - 1/2N = O(N^2)

선택 정렬 알고리즘은 배열의 종류와 시간 복잡도 사이에 관계가 없다. 따라서 최악의 경우와 최선의 경우의 시간 복잡도는 같다. 



- 삽입 정렬 알고리즘(insertion sort)

삽입 정렬은 전체 배열 중 정렬되어 있는 부분 배열에 새 원소를 끼워넣은 일은 반복하는 방식으로 동작한다. 

```c++
void insertionSort(vector<int>& A){
  for(int i = 0; i < A.size(); ++i){
    int j = i;
    while(j > 0 && A[j-1] > A[j]){
      swap(A[j-1],A[j]);
      --j;
    }
  }
}
```

다음은 해당 코드에서 i = 4 일때 동작 과정이다.

| 1    | 4    | 7    | 11   | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      | **   |      |
| 1    | 4    | 5    | 7    | 11   | 6    |



삽입 정렬 알고리즘의 시간 복잡도를 계산해보자.

삽입 정렬 알고리즘은 배열의 구성에 따라 시간 복잡도가 다르다.

- 최선의 경우 : 정렬되어 있는 배열이 들어오면 while 문이 바로 종료된다. 따라서 전체 시간 복잡도는 O(N)이 된다.
- 최악의 경우 : 역으로 정렬되어 있는 배열이 들어올 경우 while 문의 시간 복잡도가 O(N)이 된다. 따라서 전체 시간 복잡도는 O(N^2)이다. 

삽입 정렬 알고리즘은 실제로 시간 복잡도가 O(N^2)인 정렬 알고리즘 중에는 가장 빠른 알고리즘으로 알려진다. 



## - 시간 복잡도의 분할 상환 분석

알고리즘의 시간 복잡도는 항상 반복문의 개수를 세는 것으로만 결정하지 않는다. 가끔 그보다 더 정확한 시간 복잡도를 계산하는 것도 가능하다. 그 대표적인 예야 시간 복잡의 분할 상확 분석이다. 