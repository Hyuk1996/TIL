# 6.2 재귀 호출과 완전 탐색

## - 재귀 호출

재귀 함수란 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그중 한 조각을 수행하고, 나머지는 자기 자신을 호출해 수행하는 함수이다. 

다음은 반복문을 재귀함수로 바꾼 예이다. 

------

**반복문**

```c++
// 1부터 n까지의 합
int sum(int n){
  int ret = 0;
  for(int i = 1; i <= n; ++i)
    ret += i;
  return ret;
}
```

<br/>

**재귀함수**

```c++
int recursiveSum(int n){
  if(n == 1) return 1;
  return n + recursiveSum(n-1);
}
```

------

위 재귀함수의 if 문은 쪼개지지 않는 가장 작은 작업으로 기저 사례(base case)라고 한다. 모든 재귀함수는 이와 같이 기저 사례에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다. 또 기저 사례를 선택할 때는 존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록 해야 한다. 

<br/>

재귀함수는 기존에 반복문을 사용해 작성하던 코드를 다르게 짤 수 있는 방법을 제공해 준다. 이는 문제 특성에 따라 코딩을 간편하게 해주는 강력한 무기가 될 수 있다. 

다음은 그 예이다. 

------

**반복문**

```c++
// n개의 원소 중 네 개를 고르는 모든 경우를 출력
for(int i = 0; i < n; ++i)
  for(int j = i+1; j < n; ++j)
    for(int k = j+1; k < n; ++k)
      for(int l = k+1; l < n; ++l)
        cout << i << " " << j << " " << k << " " << l << endl;
```

<br/>

**재귀함수**

```c++
// n: 전체 원소, picked: 지금까지 고른 원소들의 번호, toPick: 고를 원소
void pick(int n, vector<int>& picked, int toPick){
  //기저 사례
  if(toPick == 0){printPicked(picked); return;}
  //고를 수 있는 가장 작은 번호 계산
  int smallest = picked.empty() ? 0 : picked.back() + 1;
  for(int next = smallest; next < n; ++next){
    picked.push_back(next);
    pick(n, picked, toPick-1);
    picked.pop_back();
  }
}
```

반복문을 통해서 문제를 해결하면 코드가 복잡해진다. 그리고 골라야 하는 원소가 많아지면 코드가 더 길어지는 단점이 있다. 이러한 문제를 해결하기 위해 재귀함수를 이용해 간편하게 구현했다. 이것이 재귀함수의 장점이다. 

------

<br/>

## - 재귀호출 예제 문제 : 보글 문제

다음은 재귀호출을 이용해 완전탐색 알고리즘을 구현한 예이다. 

Q. 보글은 그림과 같은 5X5 크기의 알파벳 격자를 가지고 하는 게임입니다. 이때 게임의 목적은 상하좌우/대각선으로 인접한 칸들의 글자들을 이어서 단어를 찾아내는 것입니다. 각 글자들은 대각선으로도 이어질 수 있으며, 한 글자가 두 번 이상 사용될 수도 있습니다. 

| U    | R    | L    | P    | M    |
| ---- | ---- | ---- | ---- | ---- |
| X    | P    | R    | E    | T    |
| G    | I    | A    | E    | T    |
| X    | T    | N    | Z    | Y    |
| X    | O    | Q    | R    | S    |

이때 주어진 칸에서 시작해 특정 단어를 찾을 수 있는지 확인해보자.

<br/>

A. 간단한 방법은 완전 탐색을 이용해, 단어를 찾아낼 때까지 인접한 칸을 하나씩 시도해 보는 것이다. 이를 위해 재귀함수를 사용한다.

일을 가장 자연스럽게 하는 방법은 각 글자를 하나의 조각으로 만드는 것이다. 그리고 기저 사례는 다음과 같이 설정한다.

1. 시작 위치에 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
2. (1번 경우에 해당하지 않는 경우) 원하는 단어가 한 글자인 경우 항상 성공

**간결한 코드를 작성하는 팁** : 입력이 잘못되거나 범위에서 벗어난 경우도 기저 사례로 택해 맨 처음에 처리하기.

<br/>

**구현**

```c++
const int dx[8] = {-1, -1, -1, 1, 1, 1, 0, 0}; // 코드와 데이터 분리
const int dy[8] = {-1, 0, 1, -1, 0, 1 -1, 1};
bool hasWord(int y, int x, const string& word){
  // 기저 사례
  if(!inRange(y,x)) return false;
  if(board[y][x] != word[0]) return false;
  if(word.size() == 1) return true;
  // 인접한 8칸 검사 
  for(int direction = 0; direction < 8; ++direction){
    int nextY = y + dy[direction], nextX = x + dx[direction];
    if(hasWord(nextY, nextX, word.substr(1)))
      return true;
  }
  return false;
}
```

------

<br/>

## - 시간 복잡도 분석

완전 탐색 알고리즘의 시간 복잡도를 계산하는 것은 비교적 단순하다. 

모든 경우 시간 안에 동작함을 확인하기 위해서는 후보의 최대 수를 계산하면 된다. 

<br/>

## - 완전 탐색 레시피

완전 탐색으로 해결하기 위해 필요한 과정은 대략 다음과 같다.

1. 문제에서의 최대 크기 입력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을지 가늠한다. 만약 불가능하면 다른 알고리즘 패러다임을 이용해야 한다. 
2. 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다. 각 선택은 후보를 만드는 과정의 한 조각이 된다.
3. 그중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답은 재귀 호출을 통해 완성한다.
4. 조각이 하나밖에 남지 않거나, 하나도 남지 않는 경우에는 기저 사례로 선택한다.

<br/>

## - 이론적 배경: 재귀 호출과 부분 문제 

재귀호출을 공부하면서 짚고 넘어가야 할 중요한 개념 중의 하나로 문제(problem)와 부분 문제(subproblem)의 정의가 있다.

문제(problem)란 항상 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 의미한다. 그리고 문제를 구성하는 조각중 하나를 뺀 것을 부분 문제라고 한다.