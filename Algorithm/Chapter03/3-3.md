# 3.3 자주 하는 실수

같은 실수를 반복하기보다는 실수에서 배우는 것이 좋다. 이보다 더 좋은 것은 남의 실수로부터 배워 유사한 실수를 하지 않는 것이다.

이 파트에서는 프로그래밍 대회에서 자주 저지르는 실수 중 대표적인 실수를 소개한다.



# 실수들

- 산술 오버플로
- 배열 범위 밖 원소에 접근
- 일관되지 않은 범위 표현 방식 사용하기
- Off-by-one- 오류
- 컴파일러가 잡아주지 못하는 상수 오타
- 스택 오버플로
- 다차원 배열 인덱스 순서 바꿔 쓰기
- 잘못된 비교 함수 작성
- 최소, 최대 예외 잘못 다루기
- 연산자 우선순위 잘못 쓰기
- 너무 느린 입출력 방식 선택
- 변수 초기화 문제



## - 산술 오버풀로

산술 오버플로는 대회에서 가장 자주 등장하는 실수이다. 따라서 '변수 범위의 이해'에서 더 자세히 다룬다.



## - 배열 범위 밖 원소에 접근

C/C++에서는 배열의 원소에 접근할 때 해당 인덱스가 배열 범위 안에 있는지 확인해 주지 않는다. 이는 속도가 중요한 프로그램에서는 좋은 특징이지만  배열 범위 밖 원소에 접근하는 오류를 범할 수 있다. 

위와 같은 실수를 방지하려면 배열 크기를 정할 때 계산을 신중히 해야 한다.



## - 일관되지 않은 범위 표현 방식 사용하기

일관되지 않은 범위 표현 방식의 사용은 배열 범위 밖 원소를 참조하는 실수를 발생시키는 원인 중 하나이다. 따라서 프로그램 내에서는 한 가지 방법으로만 범위를 표현할 필요가 있다. 

범위 표현 방식으로는 세 가지가 있다. 첫 번째는 닫힌 구간이다. 두 번째는 열린 구간이다. 세 번째는 반 열린 구간이다. 

C/C++의 STL에서는 반 열린 구간 방식을 사용한다.



## - Off-by-one 오류

Off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 가리킨다. 해당 오류는 최소 입력으로 내가 짠 코드가 어떻게 동작할지를 되새겨 보면 방지할 수 있다.  



## - 컴파일러가 잡아주지 못하는 상수 오타

변수명이나 함수명의 오타는 컴파일러가 잡아줄 수 있다. 하지만 상수 오타는 컴파일러가 잡아주지 않는다. 따라서 상수를 이용할 때는 오타의 가능성을 생각하고 신중하게 작성해야한다. 



## - 스택 오버플로

해당 오류는 재귀 호출의 깊이가 너무 깊어지면 발생하는 오류이다. 해당 오류를 피하기 위해서는 스택의 최대 크기를 인지하고 있어야 한다. 

*C/C++는 지역변수로 선언된 변수나, 클래스의 인스턴스가 기본적으로 스택에 저장되기 때문에 더 주의해야 한다.



## - 다차원 배열 인덱스 순서 바꿔 쓰기

특정 배열에 접근하는 위치를 하나로 통일하면 해당 실수를 방지할 수 있다. 



## - 잘못된 비교 함수 작성

### 들어가기 전

*비교 함수: 반환값이 참이면 왼쪽 매개변수가 오른쪽 매개변수보다 앞에 온다.



종종 비교 함수를 구현할 때 연산자 성질을(strict weak ordering)을 만족하지 못하여 오류가 생기는 상황이 있다. 

-  연산자 성질

1. a<a는 항상 거짓. (비반사성)
2. a<b가 참이면 b<a는 거짓. (비대칭성)
3. a<b가 참이고, b<c가 참이면 a<c이다.(전이성)
4. a<b와 b<a가 모두 거짓이면 a와 b는 같은 값이다.(상등 관계의 전이성)



다음은 연산자 성질을 지키지 못한 예이다. 

상황 : 정수 집합을 저장하는 vector<IntegerSet> 을 순서대로 정렬, 단 A가 B의 진부분 집합이면 A는 B보다 먼저 처리되어야 한다. 

```c++
// a가 b의 진부분집합이면 true, 아니면 false 반환
bool isProperSubset(const IntegerSet& a, const Integerset& b);
// a가 b의 진부분집할일 때 a가 앞에 오도록 집합들을 정렬
bool operator < (const IntegerSet& a, const IntegerSet& b){
if(isProperSubset(a,b)) return true;
if(isProperSubset(b,a)) return false;
return false;
}
```

위와 같은 코드는 연산자 성질 4번 만족하지 않는다. 예를 들어 {1}, {2}, {2,3}의 경우 4번 규칙에 의해 {1} == {2} == {2,3}으로 인식되어 제대로 정렬되지 않는다. 

따라서 위의 코드는 다음과 같이 수정되어야 한다. 

```c++
bool operator < (const IntegerSet& a, const IntegerSet& b){
	if(isProperSubset(a, b)) return true;
  if(isProperSubset(b, a)) return false;
  // size가 다르면 size가 작은 집합이 앞으로
  if(a.size() != b.size()) return a.size() < b.size();
  // 사전순으로 비교
  return lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
}
```


하지만 위의 코드도 수정할 필요가 있다. 사이즈로 비교함으로 진부분집합 확인은 의미가 없어진다.



정리하자면 비교 함수를 작성할 두 가지 경우를 생각해야 한다.

첫 번째는 연산자 성질이다. 두 번째는 단순한 크기 비교와, 사전순 비교로 만들 수 있는 비교 함수를 더 복잡하게 만드는 것을 피해야 한다. 



## - 최소, 최대 예외 잘못 다루기

문제에 주어진 입력의 최솟값과 최댓값이 예외가 되는 문제는 종종 존재한다. 따라서 주어진 입력의 최솟값과 최댓값으로 나의 코드를 테스트해보는 것은 이러한 실수를 방지해 준다.



## - 연산자 우선순위 잘못 쓰기

연산자 우선순위에 의한 오류는 찾기 힘들 수 있다. 따라서 연산자 우선순위를 명확하게 숙지하는 것이 좋다. 그렇지 못한 경우는 괄호를 이용해 해당 실수를 방지할 수 있다. 



## - 너무 느린 입출력 방식 선택

입출력 양이 많은 문제에서는 어떤 입출력 방식을 사용하느냐에 따라 문제의 성공 여부가 갈릴 수 있다. 따라서 내가 사용하는 언어에서 어떤 입출력 방식이 지원되고, 어느 쪽이 빠른지를 미리 점검해두는 것이 좋다.



## - 변수 초기화 문제

이전 입력에 사용되었던 전역 변수 값을 초기화 하지 않고 사용하면 오류가 발생할 수 있다. 따라서 새로운 테스트 케이스를 처리할 때마다 변수를 초기화해줘야 한다.

