# 코딩과 디버깅에 관하여

- 도입
- 좋은 코드를 짜기 위한 원칙
- 자주 하는 실수
- 디버깅과 테스팅
- 변수 범위의 이해
- 실수 자료형의 이해



<hr/>

## 도입: 코딩의 중요성을 간과하지 말라

일반적으로 사람들은 프로그래밍 대회에서 좋은 성적을 내기 위해서는 알고리즘이나 자료구조에 대한 지식은 중요하다고 생각하지만 코딩의 중요성은 간과하는 경우가 많다.

하지만 프로그램 대회에서 좋은 성적을 내기 위해서는 단순히 내가 아는 알고리즘과 자료구조를 이용해 빨리 코드를 작성하기보다는 읽기 쉬운 코드를 작성하는 것이 더 중요하다.

따라서 프로그래밍 대회에서 얻을 수 있는 가장 큰 소득 중 하나는 간결하고 효율적인 프로그램을 작성하는 능력이다.



<hr/>

## 좋은 코드를 짜기 위한 원칙

프로그래밍 대회에서 작성하는 좋은 코드의 조건은 실무에서 작성하는 좋은 코드의 조건과 크게 다르지 않다. 

이번 파트에서는 대회에서 좋은 코드를 짜기 위한 원칙에 대해 설명할 것이다.

 

### 원칙

- 간결한 코드를 작성하기
- 적극적으로 코드 재사용하기
- 표준 라이브러리 공부하기
- 항상 같은 형태로 프로그램을 작성하기
- 일관적이고 명료한 명명법 사용하기
- 모든 자료를 정규화해서 저장하기
- 코드와 데이터를 분리하기



### - 간결한 코드를 작성하기

프로그래밍 대회에서 좋은 코드를 작성하는 첫 번째 원칙은 가장 간결한 코드를 작성하는 것이다. 이를 위해 실무에서는 잘 사용하지 않는 방법이 사용되곤 한다. 첫 번째는 전역 변수의 광범위한 사용이다. 두 번째는 매크로를 이용해서 간결한 코드를 작성하는 것이다. 



### - 적극적으로 코드 재사용하기

코드를 작성할 때 코드를 모듈화하면 더 간결한 코드를 작성할 수 있다. 예를 들면 같은 코드가 세 번 이상 등장한다면 해당 코드를 함수로 분리해서 사용한다는 기본 원칙을 세우는 것이 있다. 

간결한 코드는 코드의 오류를 최소화할 수 있고, 디버깅 시간을 단축할 수 있다. 

하지만 반복되는 코드를 함수로 분리할 때 주의할 점이 있다. 일반적으로 실무에서는 한 가지 함수가 두 가지 일을 하는 것을 지양한다. 하지만 프로그래밍 대회에서 이러한 원칙을 적용하는 데 한계가 있다.



### - 표준 라이브러리 공부하기

간결한 코드를 작성하기 위한 또 다른 중요한 원칙은 표준 라이브러리를 사용하는 것이다. 표준 라이브러리를 사용하면 같은 팀원끼리 코드를 더 이해하기 쉽고, 불필요한 코드의 작성도 피할 수 있다. 따라서 기본적으로 사용하는 언어의 표준 라이브러리를 잘 알아야 한다.



### - 항상 같은 형태로 프로그램을 작성하기

프로그래밍 대회 문제를 풀다 보면 사람들은 같은 코드를 다양한 방식으로 짭니다. 이런 방식은 처음에 내가 이해하기 쉬운 코드를 찾기 위한 방법으로는 좋은 방법이다. 하지만 대회에서는 위와 같은 방법은 비효율적이다. 따라서 한 번 검증된 코드를 반복적으로 사용할 필요가 있다.  



### - 일관적이고 명료한 명명법 사용하기

모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이고, 사용하는 언어의 표준 라이브러리에서 사용하는 명명규약을 익히는 것이 좋다. 

예를 들어

<pre>
  <code>
  bool judge(int y, int x, int cy, int cx, int cr);
  bool isInsideCircle(int y, int x, int cy, int cx, int cr);
  </code>
</pre>

첫 번째 함수명을 쓴 것보다 두 번째 함수명을 쓴 것이 함수가 무슨 역할을 하는지 더 직관적으로 알 수 있다.



### - 모든 자료를 정규화해서 저장하기

좋은 코드의 또 다른 원칙은 같은 자료를 두 가지 형태로 저장하지 않는 것이다. 같은 자료를 두 가지 형태로 저장하면 해당 자료형을 매개변수로 받는 함수의 구현이 까다로워지고, 프로그램 수행 중 미묘한 버그가 발생할 수 있다.

보통 정규화 과정은 자료를 입력받거나 계산하자마자 곧장 이루어져야 한다. 



### - 코드와 데이터를 분리하기

코드의 논리와 상관 없는 데이터는 가능한 분리하는 것이 좋다.

예를 들어

<pre>
  <code>
  string getMonthName(int month){
  if(month == 1) return "January";
  if(month == 2) return "February";
  ...
  return "December";
  }
  </code>
</pre>

위와 같은 코드보다는 아래의 코드가 더 좋은 코드다.

<pre>
  <code>
  const string monthName[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
  ...
  string getMonthName(int month){
  return monthName[month - 1];
  }
  </code>
</pre>



<hr/>

## 자주 하는 실수

같은 실수를 반복하기보다는 실수에서 배우는 것이 좋다. 이보다 더 좋은 것은 남의 실수로부터 배워 유사한 실수를 하지 않는 것이다.

이 파트에서는 프로그래밍 대회에서 자주 저지르는 실수 중 대표적인 실수를 소개한다.



## 실수들

- 산술 오버플로
- 배열 범위 밖 원소에 접근
- 일관되지 않은 범위 표현 방식 사용하기
- Off-by-one- 오류
- 컴파일러가 잡아주지 못하는 상수 오타
- 스택 오버플로
- 다차원 배열 인덱스 순서 바꿔 쓰기
- 잘못된 비교 함수 작성
- 최소, 최대 예외 잘못 다루기
- 연산자 우선순위 잘못 쓰기
- 너무 느린 입출력 방식 선택
- 변수 초기화 문제



### - 산술 오버풀로

산술 오버플로는 대회에서 가장 자주 등장하는 실수이다. 따라서 '변수 범위의 이해'에서 더 자세히 다룬다.



### - 배열 범위 밖 원소에 접근

C/C++에서는 배열의 원소에 접근할 때 해당 인덱스가 배열 범위 안에 있는지 확인해 주지 않는다. 이는 속도가 중요한 프로그램에서는 좋은 특징이지만  배열 범위 밖 원소에 접근하는 오류를 범할 수 있다. 

위와 같은 실수를 방지하려면 배열 크기를 정할 때 계산을 신중히 해야 한다.



### - 일관되지 않은 범위 표현 방식 사용하기

일관되지 않은 범위 표현 방식의 사용은 배열 범위 밖 원소를 참조하는 실수를 발생시키는 원인 중 하나이다. 따라서 프로그램 내에서는 한 가지 방법으로만 범위를 표현할 필요가 있다. 

범위 표현 방식으로는 세 가지가 있다. 첫 번째는 닫힌 구간이다. 두 번째는 열린 구간이다. 세 번째는 반 열린 구간이다. 

C/C++의 STL에서는 반 열린 구간 방식을 사용한다.



### - Off-by-one 오류

Off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 가리킨다. 해당 오류는 최소 입력으로 내가 짠 코드가 어떻게 동작할지를 되새겨 보면 방지할 수 있다.  



### - 컴파일러가 잡아주지 못하는 상수 오타

변수명이나 함수명의 오타는 컴파일러가 잡아줄 수 있다. 하지만 상수 오타는 컴파일러가 잡아주지 않는다. 따라서 상수를 이용할 때는 오타의 가능성을 생각하고 신중하게 작성해야한다. 



### - 스택 오버플로

해당 오류는 재귀 호출의 깊이가 너무 깊어지면 발생하는 오류이다. 해당 오류를 피하기 위해서는 스택의 최대 크기를 인지하고 있어야 한다. 

*C/C++는 지역변수로 선언된 변수나, 클래스의 인스턴스가 기본적으로 스택에 저장되기 때문에 더 주의해야 한다.



### - 다차원 배열 인덱스 순서 바꿔 쓰기

특정 배열에 접근하는 위치를 하나로 통일하면 해당 실수를 방지할 수 있다. 



### - 잘못된 비교 함수 작성

#### 들어가기 전

*비교 함수: 반환값이 참이면 왼쪽 매개변수가 오른쪽 매개변수보다 앞에 온다.



종종 비교 함수를 구현할 때 연산자 성질을(strict weak ordering)을 만족하지 못하여 오류가 생기는 상황이 있다. 

-  연산자 성질

1. a<a는 항상 거짓. (비반사성)
2. a<b가 참이면 b<a는 거짓. (비대칭성)
3. a<b가 참이고, b<c가 참이면 a<c이다.(전이성)
4. a<b와 b<a가 모두 거짓이면 a와 b는 같은 값이다.(상등 관계의 전이성)

다음은 연산자 성질을 지키지 못한 예이다. 

상황 : 정수 집합을 저장하는 vector<IntegerSet> 을 순서대로 정렬, 단 A가 B의 진부분 집합이면 A는 B보다 먼저 처리되어야 한다. 

<pre>
  <code>
  // a가 b의 진부분집합이면 true, 아니면 false 반환
  bool isProperSubset(const IntegerSet& a, const Integerset& b);
  // a가 b의 진부분집할일 때 a가 앞에 오도록 집합들을 정렬
  bool operator < (const IntegerSet& a, const IntegerSet& b){
  if(isProperSubset(a,b)) return true;
  if(isProperSubset(b,a)) return false;
  return false;
  }
  </code>
</pre>

위와 같은 코드는 연산자 성질 4번 만족하지 않는다. 예를 들어 {1}, {2}, {2,3}의 경우 4번 규칙에 의해 {1} == {2} == {2,3}으로 인식되어 제대로 정렬되지 않는다. 

따라서 위의 코드는 다음과 같이 수정되어야 한다. 

<pre>
  <code>
  bool operator < (const IntegerSet& a, const IntegerSet& b){
  if(isProperSubset(a, b)) return true;
  if(isProperSubset(b, a)) return false;
  // size가 다르면 size가 작은 집합이 앞으로
  if(a.size() != b.size()) return a.size() < b.size();
  // 사전순으로 비교
  return lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
  }
  </code>
</pre>

하지만 위의 코드도 수정할 필요가 있다. 사이즈로 비교함으로 진부분집합 확인은 의미가 없어진다.



정리하자면 비교 함수를 작성할 두 가지 경우를 생각해야 한다.

첫 번째는 연산자 성질이다. 두 번째는 단순한 크기 비교와, 사전순 비교로 만들 수 있는 비교 함수를 더 복잡하게 만드는 것을 피해야 한다. 



### - 최소, 최대 예외 잘못 다루기

문제에 주어진 입력의 최솟값과 최댓값이 예외가 되는 문제는 종종 존재한다. 따라서 주어진 입력의 최솟값과 최댓값으로 나의 코드를 테스트해보는 것은 이러한 실수를 방지해 준다.



### - 연산자 우선순위 잘못 쓰기

연산자 우선순위에 의한 오류는 찾기 힘들 수 있다. 따라서 연산자 우선순위를 명확하게 숙지하는 것이 좋다. 그렇지 못한 경우는 괄호를 이용해 해당 실수를 방지할 수 있다. 



### - 너무 느린 입출력 방식 선택

입출력 양이 많은 문제에서는 어떤 입출력 방식을 사용하느냐에 따라 문제의 성공 여부가 갈릴 수 있다. 따라서 내가 사용하는 언어에서 어떤 입출력 방식이 지원되고, 어느 쪽이 빠른지를 미리 점검해두는 것이 좋다.



### - 변수 초기화 문제

이전 입력에 사용되었던 전역 변수 값을 초기화 하지 않고 사용하면 오류가 발생할 수 있다. 따라서 새로운 테스트 케이스를 처리할 때마다 변수를 초기화해줘야 한다.



<hr/>

## 디버깅과 테스팅

- 디버깅에 관하여
- 테스트에 관하여



### - 디버깅에 관하여

일반적으로 내가 짠 프로그램이 예상대로 동작하지 않는다면 디버거를 이용해서 원인을 찾을 것이다. 그러나 프로그래밍 대회에서는 다음과 같은 이유 때문에 디버깅을 쓰는 것이 효율이 떨어지는 경우가 있다.

- 소스코드가 대부분 짧기 때문에 눈으로 디버깅하는 것이 더 빠를 수 있다.
- 재귀 호출이나 중복 반복문이 많을 경우 디버거로 디버깅을 하기에 적합하지 않다.

따라서 프로그래밍 대회를 준비하는 사람들은 디버거 없이 프로그램의 버그를 찾아내는 연습을 할 필요가 있다. 그 방법은 다음과 같은 방법이 있다.

- 작은 입력을 가지고 내가 짠 프로그램이 제대로 동작하는지 확인한다.
- 단정문을 쓴다. (단정문이란 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료 시키는 함수 또는 구문이다.)
- 프로그램의 계산 중간 결과 값을 출력한다.



### - 테스트에 관하여

프로그래밍 대회에서는 답안을 제출하기 전에 가능한 많은 예제 입력을 만들어 테스트하는 것이 좋다. 이를 위한 방법에는 스캐폴딩이 있다. 

다음은 스캐폴딩을 이용해 직접 작성한 정렬 함수를 테스트를 자동화하는 예이다. 

```C++
//테스트할 정렬 함수
void mySort(vector<int>& array);
//주어진 배열을 문자로
string toString(const vector<int>& array);
int main(){
  while(true){
    int n = rand() % 100 + 1;
    vector<int> input(n);
    for(int i=0; i<n; ++i)
      input[i] = rand();
    vector<int> mySorted = input;
    mySort(mySorted);
    vector<int> reference = input;
    sort(reference.begin(), reference.end());
    if(mySorted != reference){
      cout << "Mismatch" << endl;
      cout << "Input: " << toString(input) << endl;
      cout << "Expectd: " << toString(reference) << endl;
      cout << "Got: " << toString(mySorted) << endl;
      break;
    }
  }
}
```





------

## 







